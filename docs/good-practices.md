<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Good Practices](#good-practices)
  - [Choose a 64chars password for redis](#choose-a-64chars-password-for-redis)
  - [Use memcached as cache](#use-memcached-as-cache)
  - [Redis as a persistent store (AOF)](#redis-as-a-persistent-store-aof)
  - [Don't run decidim with privilegied postgres user](#dont-run-decidim-with-privilegied-postgres-user)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<!--
CONTRIBUTOR; WARNING
This file is generated by the /update-documentation.rb script. 
Don't edit it directly.

@see /update-documentation.rb
@see /templates/docs/good-practices.md.erb
-->

# Good Practices

## Choose a 64chars password for redis
> Redis internally stores passwords hashed with SHA256. If you set a password and check the output of ACL LIST or ACL GETUSER, you'll see a long hex string that looks pseudo random. […]
> Using SHA256 provides the ability to avoid storing the password in clear text while still allowing for a very fast AUTH command, which is a very important feature of Redis and is coherent with what clients expect from Redis.
> **However ACL passwords are not really passwords**. They are shared secrets between the server and the client, because the password is not an authentication token used by a human being. […]
> For this reason, slowing down the password authentication, in order to use an algorithm that uses time and space to make password cracking hard, is a very poor choice. What we suggest instead is to **generate strong passwords**, so that nobody will be able to crack it using a dictionary or a brute force attack even if they have the hash […]
> […] 64-byte alphanumerical string […] is long enough to avoid attacks and short enough to be easy to manage[…]
> Source: [_Redis Documentation_. ACL, Redis Access Control List, Key permissions. (visited 08/11/2022)](https://redis.io/docs/management/security/acl/)

## Use memcached as cache
**Avoid using redis as cache**. Redis should be configured in persistent mode (AOF) for sidekiq running. It is not a well suited configuration for caching, and you shouldn't use the same redis instance to do cache and queuing.
Read more on this particular issue in [the sidekiq wiki:](https://github.com/mperham/sidekiq/wiki/Using-Redis#multiple-redis-instances)

## Redis as a persistent store (AOF)
Sidekiq is used to send emails and do remote tasks. It should be configured as a persistent store (AOF).
Read more on configuring redis persistence on the [Redis Documentation](https://redis.io/docs/management/persistence/).

## Don't run decidim with privilegied postgres user
A good practice is to run decidim with unpriviligied user (can not create table, truncate it or alter it). 
A common way to put this in practice is to have CI/CD deployment script (through github actions for example), where: 

- While deploying, deploy a temporary instance (sidecars) with priviliged database access. Migrate the database.
- Once `rails db:migrate:status` gives only `up` migrations, redeploy an instance without priviliged accesses.

**NB** running `rails db:migrate` while a rails application is running is most of the time a bad idea (connection to postgres can hangs). Always check `rails db:migrate:status` after a migration, to be sure all migration passed.

